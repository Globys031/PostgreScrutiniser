// Package resourceConfig provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package resourceConfig

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xYW2/bNhT+KwS3hxTQbDlpt8JvzW7Ibujabn3oDOGYOpJYi6TKix0v8H8fDiXbiiwk",
	"LYoFLdCXQBap79y+c8sNF0Y1RqP2js9vuBMVKoiPP1pr7O/oHJRIvxtrGrReYjxFOs3U8dhvG+Rz7ryV",
	"uuS7XcItvgvSYs7nbwbXF8n+ulm+ReF5vO1MsAK/N7qQZRRxDaqpkc/f3PAcPcja8Tl/VUnHXChLdF4a",
	"zTbgmIIc2XLLcrmWudQlE8Fa1J7BGmQNyxqZQmXs9uz8/OLb2ex8kqary0f0yWMGOqeHymyYAr1lELxZ",
	"gwhBZQqus42xK7Tu7OIRA4vMoecJRx1UtoaoEE94aXwWLeTzAmqHCdegyLweFuFkChVPeKc95gQR6N7s",
	"YpZ+d84THrT0fM5Xlzzh+8NvZnyX9F3wK1qNNWvAgkKPlmmbVaHEBkp0jNyDnnnD0gm7RAHBITMF8xX4",
	"hD03zpcWX/75GxOgtfGMwoTOM0JgEWJg4I0pisToxNvt7i5jCSDbA5zaaIriaGDPPHq/WyQDfh2spUcn",
	"rGwo2nzOf2gPmNSFsYqCvam2DFiEi2w4iObJkJW3DBsiuwaFLCQ6tqnAM/qU/BaBo099pJYJdc4qWOMY",
	"fM85d8Gjr9AyUaFYsdJ4Bpq1Xx0gl8bUCJowW/cO4f4A1YUV97qNKdQlocssOg/WnwK97rQB1l0hBu1z",
	"l0Hho6agS7KepLWBG9P0JOhDWX/HIBET2UbWNVviMVqdKBu0jn4m54xZ1DJoiPyXlp7coRBcsKgo+89c",
	"wpRL2OoyYU/pD3oxeTSGeae69zl5UOpiuPaQ91e65+BF9TKW3WHR+9AikqZpGkvF+yfkaeJ9FNsegADj",
	"3h4KPvU7aYciWOm30duttUsEi/ZZ8NXx10/GKqAi9cvrVwQdbxPR4+lRo8r7hu8ImGrRqa0vujizNtDB",
	"Ah049uz5FYFIT2Hm+4IsbPBSSxclrNG6FmQ2SScUVG4a1NBIPucX8VXCG/BVNGK6Z1SrQ41+xPMWHXrH",
	"oK6ZMNpTfkjtZB7D2rRKuHf1hNg2EUYX7GwjG+on3u2/oNwhrkRDrvJYjUnai1uMJrZZdI3RrnXyefpk",
	"pBwGIdBRpWlvko2P0xld7KTRIzRNLUWUN33r6MP9jEJPX1ss+Jx/NT0OMdNugpneGl9ilG7Lf2VWqJmS",
	"zhHZjGUKauoomJMmT9L0wTR5iXaNlsVYtF0gXikg1P7BlAgarxsUlIadDruEeygdJdmBXwtqcejHuO6D",
	"1S299reJNUfed93Oogu1d//oEyr9jP5eHp1/kD+kR+Xuc8xg7twd0hushe2Yq74w9zNlbkOt9pS7UTV0",
	"zGiM3jQWewuGOyFq7NhjVI1z9KXJt/83S/szwyhhjx3S24C7kzya3dGtBllrEci1HemLUNfblvAPR7Mr",
	"vYZa5odNZUku/qSS7lPl/C45DgfTmzayOxJ+dxFn3a4ierW8m8buqdmX26s8jibdauq67b0vRnez5KBP",
	"0MZattv1fgbmrgKLebYMRUFYNGnxeRx8+GHtbL/mQ9InPVfT0keeGZ+k860GJUXWCWv/U5DFpEp4Ba6i",
	"V5kKtZdUKGg+O0zWmZP/Yv8FKalAEgdAC+zLUXCdNRabKMVb0A7EvsLQmfMgVlmOTbTuxPRR9Tyqpnen",
	"J602pRRQZzkKk0tdHjVZnM7Ui4/stB/SYN+3oT58fTmw9ktH/yw6en+ni3Wmv829WRCrXbSnrULB1t3W",
	"Np9OayOgrozz86fp03RKm9VusfsvAAD//0llGoMPFQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
